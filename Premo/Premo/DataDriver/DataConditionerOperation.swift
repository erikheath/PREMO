//
//  DataConditionerOperation.swift
//

import UIKit
import CoreData

public class DataConditionerOperation: NSOperation {

    // MARK: Error Management
    public enum DataConditionerError: Int, ErrorType {
        case missingEntity = 7000
        case missingProperty = 7001
        case missingEntityUserInfo = 7002
        case missingPropertyUserInfo = 7003
        case unknownRemoteStoreType = 7004
    }

    // MARK: Properties

    let parentContext: NSManagedObjectContext

    private lazy var mainContext: NSManagedObjectContext? = {
        return self.parentContext.parentContext
    }()

    private lazy var masterContext: NSManagedObjectContext? = {
        return self.parentContext.parentContext?.parentContext
    }()

    private lazy var internalContext: NSManagedObjectContext = {
        let context = NSManagedObjectContext(concurrencyType: .PrivateQueueConcurrencyType)
        context.parentContext = self.parentContext
        return context
    }()

    let responseData: NSData

    let URLRequest: NSURLRequest

    let graphManager: OperationGraphManager

    private var traversedIdentifiers: Array<NSManagedObjectID> = Array()


    // MARK: Object Lifecycle

    init (parentContext: NSManagedObjectContext, data: NSData, URLRequest: NSURLRequest, graphManager: OperationGraphManager) {
        self.parentContext = parentContext
        self.responseData = data
        self.URLRequest = URLRequest
        self.graphManager = graphManager
        super.init()
    }


    // MARK: Utilities

    /**
    Supported URL response types that can be processed by the data conditioning system.
    */
    public enum URLResponseProcessingType: String, CustomStringConvertible {
        case Image = "Image"
        case JSON = "JSON"

        public var description:String { return self.rawValue }

    }

    /**
     Determines the type of URL Response received by interrogating the response, determining if it has the necessary components to attempt processing.

     - Throws: If a supported type can not be determined, an error is thrown.

     - Returns: A URL response processing type corresponding to the supported types.

     */
    public func validateURLResponseType() throws -> URLResponseProcessingType {

        guard let entity = self.URLRequest.requestEntity else {
            throw DataConditionerError.missingEntity
        }

        guard let _ = entity.userInfo else {
            throw DataConditionerError.missingEntityUserInfo
        }

        switch self.URLRequest.requestProperty {

        case let targetProperty where targetProperty is NSRelationshipDescription:

            guard let _ = targetProperty?.userInfo else { throw DataConditionerError.missingPropertyUserInfo }

            return URLResponseProcessingType.JSON

        case let targetProperty where targetProperty is NSAttributeDescription:

            guard let userInfo = targetProperty?.userInfo else { throw DataConditionerError.missingPropertyUserInfo }

            switch userInfo[kRemoteStoreURLType] as? String {

            case let x where x == kRemoteStoreURLTypeImage:
                return URLResponseProcessingType.Image

            case let x where x == kRemoteStoreURLTypeFeed:
                return URLResponseProcessingType.JSON

            default:
                throw DataConditionerError.unknownRemoteStoreType
            }

        default:
            return URLResponseProcessingType.JSON

        }
    }

    /**
     Attempts to save the passed in context, optionally attempting to fix validation errors if any are encountered.
     
     - Throws: If errors are encountered or if they can not be repaired, throws the error generated by trying to save the context.
     */
    public func saveContext( context: NSManagedObjectContext, fixValidationErrors: Bool) throws {

        var saveError: ErrorType? = nil

        context.performBlockAndWait { () -> Void in

            var caughtError: NSError? = nil

            do {
                if context.hasChanges {
                    try context.save()
                    return
                } else {
                    return
                }
            } catch {
                caughtError = error as NSError
            }

            do {
                if caughtError != nil && fixValidationErrors == true {
                    try self.processValidationErrors(caughtError!, context: context)
                    try context.save()
//                    print("Saved without errors now")
                    return
                }
            } catch {
                caughtError = error as NSError
//                print(caughtError)
            }

            saveError = caughtError

        }

        if let _ = saveError {
            throw saveError!
        }

    }

    /**
     Saves the contexts, pushing all changes to the master context and persistent store if one exists.

     - Throws: In the event of a save error, returns the NSManagedObjectContext save error.
     */
    public func saveContexts() throws {

        // Writes to the internal background processing queue.
        do {

            try self.saveContext(self.internalContext, fixValidationErrors: true)

            try self.saveContext(self.parentContext, fixValidationErrors: true)

            guard let _ = self.mainContext else { return }
            try self.saveContext(self.mainContext!, fixValidationErrors: false)

            guard let _ = self.masterContext else { return }
            try self.saveContext(self.masterContext!, fixValidationErrors: false)

        } catch {
            throw error as NSError

        }
    }

    /**
     Processes the internal context to remove objects that have been invalidated by the changes made resulting from processing.
     */
    public func processValidationErrors(errors: NSError, context: NSManagedObjectContext) throws {
        // This method removes objects listed in the NSAffectedObjectsErrorKey when trying to save.

        if errors.domain == NSCocoaErrorDomain && errors.code == NSValidationMultipleErrorsError && errors.userInfo[NSDetailedErrorsKey] != nil {
            // There were multiple validation errors. Remove the objects generating the errors.
            guard let detailedErrors = errors.userInfo[NSDetailedErrorsKey] as? Array<NSError> else { return }
            for error in detailedErrors {
                guard let objectToDelete = error.userInfo[NSValidationObjectErrorKey] as? NSManagedObject else { continue }
                objectToDelete.managedObjectContext?.deleteObject(objectToDelete)

            }

        } else if errors.domain == NSCocoaErrorDomain && errors.userInfo[NSValidationObjectErrorKey] != nil {
            guard let objectToDelete = errors.userInfo[NSValidationObjectErrorKey] as? NSManagedObject else { return }
            objectToDelete.managedObjectContext?.deleteObject(objectToDelete)
        }

    }

    /**
     Resetting the contexts used in updating will relieve memory pressure on the app.

     - Note: This method should be called at the end of the operations processing of the response data as part of cleaning up processing artifacts. It should be called after all of the contexts have been saved using the saveContexts method. The internal context will be discarded when the operation exits and should not be reset while processing.

     - Warning: It is essential that writes to the primary background and master context be encapsulated so that all writes are completed prior to a reset. For example, if you are writing to a context and want to reset it after the write to relieve memory pressure, make certain to check for pending changes and commit them before issuing a reset. Failing to do so can result in an out-of-sync local cache and contexts.

     */
    public func resetContexts() throws {
        var saveError: ErrorType?

        self.parentContext.performBlockAndWait({ () -> Void in
            if self.parentContext.hasChanges {
                do {
                    try self.parentContext.save()
                    self.parentContext.reset()
                } catch {
                    saveError = error
                }
            } else {
                self.parentContext.reset()
            }
        })

        if let _ = saveError {
            throw saveError!
        }

        self.masterContext?.performBlockAndWait({ () -> Void in
            guard let _ = self.masterContext else { return }
            if self.masterContext!.hasChanges {
                do {
                    try self.masterContext!.save()
                    self.masterContext!.reset()
                } catch {
                    saveError = error
                }
            } else {
                self.masterContext!.reset()
            }
        })

        if let _ = saveError {
            throw saveError!
        }
    }


    // MARK: Operation Processing Flow

    override public func main() {
//        autoreleasepool { () -> () in

            processor: do {

                let objectIDArray:Array<NSManagedObjectID>

                let processingType = try self.validateURLResponseType()

                switch processingType {

                case .JSON:
                    objectIDArray = try JSONCollectionProcessor(operationGraphManager: self.graphManager).processJSONDataStructure(self.responseData, request: self.URLRequest, context: self.internalContext)
                    
                case .Image:
                    objectIDArray = try ImageDataProcessor().processImageData(self.responseData, request: self.URLRequest, context: self.internalContext)
                }
                
                try self.saveContexts()
                NotificationProcessor.processUpdatedObjects(objectIDArray, request: self.URLRequest)

                defer { do { try self.resetContexts() } catch { } }

            } catch {
                
                NotificationProcessor.processErrors(error as NSError, request: self.URLRequest)
                
            }
        }

}


